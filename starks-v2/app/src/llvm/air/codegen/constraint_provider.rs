use lang::constraints::{AirExpression, RowOffset};

use crate::llvm::air::codegen::GeneratedAir;
use crate::{ConstraintProvider, Field, Unity};

/// AirConstraintProvider translates the AIR expressions generated by the LLVM AIR codegen
/// into actual constraint evaluations over an expanded domain. It implements the global
/// ConstraintProvider trait for integration with the STARK pipeline.
///
/// Note: The generated AIR includes not only transition and boundary constraints but also memory
/// constraints (from memory.rs) and phi transitions (from phi_transitions.rs and phi.rs). The
/// AirGenContext already handles call stack scheduling and other state. Here we assume that the
/// final execution trace is provided as a flattened multi-column vector. The number of trace columns
/// is given by self.generated_air.num_trace_columns and the domain size is expanded_domain_sz.

pub struct AirConstraintProvider<F: Field + Clone> {
    pub generated_air: GeneratedAir<F>,
}

impl<F: Field + Clone> AirConstraintProvider<F> {
    /// A helper function to compute (base^exp) mod modulus.
    fn mod_pow(mut base: u128, mut exp: u128, modulus: u128) -> u128 {
        let mut res = 1;
        base %= modulus;
        while exp > 0 {
            if exp % 2 == 1 {
                res = (res * base) % modulus;
            }
            base = (base * base) % modulus;
            exp /= 2;
        }
        res
    }

    /// Evaluates a polynomial given by its coefficients (with coeffs[0] the constant term) at x using Horner's method.
    fn eval_poly(coeffs: &Vec<u128>, x: u128, prime: u128) -> u128 {
        let mut result = 0;
        for &coeff in coeffs.iter().rev() {
            result = (result * x + coeff) % prime;
        }
        result
    }

    /// Recursively evaluates an AirExpression at a given domain index.
    /// The evaluation environment supplies the trace evaluations for each trace column as a vector of vectors.
    /// For a Trace variant, we select the column corresponding to the AirTraceVariable's index and then
    /// pick the evaluation at the given row (adjusted by offset, with wrap-around).
    fn eval_air_expr(
        expr: &AirExpression,
        idx: usize,
        domain_size: usize,
        trace_eval_columns: &Vec<Vec<u128>>,
        prime: u128,
    ) -> u128 {
        match expr {
            AirExpression::Constant(c) => *c % prime,
            AirExpression::Add(lhs, rhs) => {
                (Self::eval_air_expr(lhs, idx, domain_size, trace_eval_columns, prime)
                    + Self::eval_air_expr(rhs, idx, domain_size, trace_eval_columns, prime))
                    % prime
            }
            AirExpression::Sub(lhs, rhs) => {
                let l = Self::eval_air_expr(lhs, idx, domain_size, trace_eval_columns, prime);
                let r = Self::eval_air_expr(rhs, idx, domain_size, trace_eval_columns, prime);
                (l + prime - r) % prime
            }
            AirExpression::Mul(lhs, rhs) => {
                (Self::eval_air_expr(lhs, idx, domain_size, trace_eval_columns, prime)
                    * Self::eval_air_expr(rhs, idx, domain_size, trace_eval_columns, prime))
                    % prime
            }
            AirExpression::Trace(var, offset) => {
                // Use the trace evaluation from the appropriate column based on the AirTraceVariable.
                let column_index = var.0 as usize; // Assuming AirTraceVariable wraps a number.
                if column_index >= trace_eval_columns.len() {
                    // If out-of-bound, return 0 (or panic if preferred).
                    return 0;
                }
                let col = &trace_eval_columns[column_index];
                let effective_idx = match offset {
                    RowOffset::Current => idx,
                    RowOffset::Next => (idx + 1) % domain_size,
                };
                col[effective_idx]
            }
            // For any other variant, default to 0.
            _ => 0,
        }
    }
}

impl<F: Field + Clone> ConstraintProvider for AirConstraintProvider<F> {
    /// Translates the AIR expressions into polynomial evaluations over the expanded domain.
    /// The procedure is as follows:
    /// 1. Split the provided trace_coeffs into columns. If the length of trace_coeffs equals
    ///    num_trace_columns * expanded_domain_sz, then each column is extracted accordingly.
    ///    Otherwise, treat trace_coeffs as a single column.
    /// 2. For each generated AIR expression (including transition, boundary, memory, and phi constraints),
    ///    evaluate it pointwise over the expanded domain using eval_air_expr.
    /// 3. Return the resulting vector of polynomial evaluations (one per constraint).
    fn get_constraints_evaluations<FieldType: Field + Clone>(
        &self,
        _field: &FieldType,
        trace_coeffs: &Vec<Vec<u128>>,
        _initial_domain_sz: usize,
        _initial_root_of_unity: Unity,
        expanded_domain_sz: usize,
        expanded_root_of_unity: Unity,
        _trace_len_original: usize,
    ) -> Vec<Vec<u128>> {
        let prime = FieldType::PRIME;

        // The `trace_coeffs` are already per-column. We need to evaluate them on the expanded domain.
        let trace_eval_columns = trace_coeffs
            .iter()
            .map(|coeffs| {
                let mut padded_coeffs = vec![0u128; expanded_domain_sz];
                padded_coeffs[..coeffs.len()].copy_from_slice(coeffs);
                crate::ntt_1d_iterative::<FieldType>(&padded_coeffs, expanded_root_of_unity)
            })
            .collect::<Vec<_>>();

        // Evaluate each AIR constraint (AirExpression) pointwise over the domain.
        let mut constraints_evals = Vec::new();
        for expr in &self.generated_air.constraints {
            let mut evals = Vec::with_capacity(expanded_domain_sz);
            for idx in 0..expanded_domain_sz {
                let val =
                    Self::eval_air_expr(expr, idx, expanded_domain_sz, &trace_eval_columns, prime);
                evals.push(val);
            }
            constraints_evals.push(evals);
        }

        constraints_evals
    }
}
